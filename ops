{"version":1,"ops":[{"type":3,"author":{"id":"563abcb2c1685b2203eb1fa3cfb44c31f71fca90"},"timestamp":1461892230,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDIxNTYwNTkzMg==","github-url":"https://github.com/DFHack/df-structures/issues/102#issuecomment-215605932"},"message":"\u003e only humans have unk_6f.\n\n[OUTSIDER_CONTROLLABLE]?","files":null},{"type":5,"author":{"id":"7c3935464acdaaae9d6fcb27abcbbe21ec75027f"},"timestamp":1465654613,"metadata":{"github-id":"MDEyOkxhYmVsZWRFdmVudDY4OTQxODY1Mg=="},"added":["research"],"removed":[]},{"type":3,"author":{"id":"406f3e8be7b2c97a6c4a5bac1456ee8ccef9cf4b"},"timestamp":1477219293,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDI1NTU4MTU0MQ==","github-url":"https://github.com/DFHack/df-structures/issues/102#issuecomment-255581541"},"message":"A thought - It could be \"large\" clothing? as that is often a modifier of human and above sized clothing. A troll can slip into a polar bear man sized suit of armor made from goblin smiths in dwarf fortress mode in play and as defined by the player quite comfortably, but their own clothes sized for them (goblin civilisation can embark with pre-clothed trolls for reference) will be \"Large xobjectx it is sized for trolls\" on description.\n\nunk_49 reasonably must correspond to 'small' if you look at it in perspective of a larger animal (dwarf downward in height where it usually starts), while unk_6f must be large. starting roughly at human size (and because of the range of variable intelligent animal men in size compared to unintelligent generic races and only playable with modding trolls this probably plays a factor) even if this  isn't precisely correct it should help steer you towards a better answer.\n\nIf you give trolls hero production or outsider controllable it wouldn't change their conditions of being excluded from the list (though a careful observation might be to see if their clothes are still listed as 'large') therefore i can't personally see the definite connection between the two.","files":null},{"type":3,"author":{"id":"dc07f1dff8eee6d97a060efd0e58b122b9009d24"},"timestamp":1542202103,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDI5OTcxMDYyOA==","github-url":"https://github.com/DFHack/df-structures/issues/102#issuecomment-299710628"},"message":"unk_6e seems to correspond to LOCAL_POPS_CONTROLLABLE while 112 (the first one after those included in the struct) corresponds to LOCAL_POPS_PRODUCE_HEROES.\nI came to these conclusions by looking at TOAD_MAN while modifying the c_variation_default.txt [CREATURE_VARIATION:ANIMAL_PERSON], generating worlds, and looking at the corresponding raw state info. Removing the two tags above toggled both of the flags to False, while removing them one at a time caused one of them to toggle, as per the conclusion above.\n\nEdit: I believe unk_49 is \"civilized\" as the list contains all the civ building races.\nDwarf, Human, Elf, Goblin, Kobold, Cave_Fish_Man, Olm_Man, Bat_Man, Cave_Swallow_Man, Amphibian_Man, Reptile_Man, Serpent_Man, Ant_Man, and Rodent_Man.\n\ncreature.flags [116] is set only on CASTE_CAN_LEARN creatures, but I can't figure out what aspect it is tied to: Blind Cave Ogre, Manera, Troll, Ogre, Giant, Blizzard Man, Troglodyte, and some, but not all, Night Creatures. Note that only the regular Giant is included, but not the Ettin, for instance.","files":null},{"type":6,"author":{"id":"dc07f1dff8eee6d97a060efd0e58b122b9009d24"},"timestamp":1580037449,"metadata":{"github-id":"MDE1OlVzZXJDb250ZW50RWRpdDM0Mzc5NDY0NQ=="},"target":"4120a226fc3b74e75d252e10bde03f0bb2e8efec10ab1ca4d2e17d5601ab339a","message":"unk_6e seems to correspond to LOCAL_POPS_CONTROLLABLE while 112 (the first one after those included in the struct) corresponds to LOCAL_POPS_PRODUCE_HEROES.\nI came to these conclusions by looking at TOAD_MAN while modifying the c_variation_default.txt [CREATURE_VARIATION:ANIMAL_PERSON], generating worlds, and looking at the corresponding raw state info. Removing the two tags above toggled both of the flags to False, while removing them one at a time caused one of them to toggle, as per the conclusion above.\n\nEdit: I believe unk_49 is \"civilized\" as the list contains all the civ building races.\nDwarf, Human, Elf, Goblin, Kobold, Cave_Fish_Man, Olm_Man, Bat_Man, Cave_Swallow_Man, Amphibian_Man, Reptile_Man, Serpent_Man, Ant_Man, and Rodent_Man.\n\ncreature.flags [116] is set only on CASTE_CAN_LEARN creatures, but I can't figure out what aspect it is tied to: Blind Cave Ogre, Manera, Troll, Ogre, Giant, Blizzard Man, Troglodyte, and some, but not all, Night Creatures. Note that only the regular Giant is included, but not the Ettin, for instance.\n\nEdit 2: Running a script over all creatures printing all creatures that have the raw string \"[SLOW_LEARNER]\" and printing all creature that have flag 116 set shows a perfect match.","files":null},{"type":3,"author":{"id":"dc07f1dff8eee6d97a060efd0e58b122b9009d24"},"timestamp":1580134665,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDU3ODc2NzczMg==","github-url":"https://github.com/DFHack/df-structures/issues/102#issuecomment-578767732"},"message":"The script used to match tags with flags:\n```\nfunction strip (str)\n  local i = string.find (str, \":\")\n  \n  if not i then\n    return str\n  end\n  return string.sub (str, 1, i - 1) .. \"]\"\nend\n\nfunction match_creature_raw_flags ()\n  local raw_set = {}\n  local flags = {}\n  \n  for i, flag in ipairs (df.global.world.raws.creatures.all [0].flags) do\n    flags [i] = flag\n  end\n    \n  for i, creature in ipairs (df.global.world.raws.creatures.all) do\n    for k, flag in ipairs (creature.flags) do\n      if flags [k] ~= creature.flags [k] then\n        flags [k] = -1\n      end\n    end\n    \n    for k, str in ipairs (creature.raws) do\n      local token = strip (str [0])\n      \n      if raw_set [token] then\n        raw_set [token] [\"count\"] = raw_set [token] [\"count\"] + 1\n        \n      else\n        raw_set [token] = {[\"count\"] = 1, [\"flags\"] = {}}\n        \n        for l, flag in ipairs (creature.flags) do\n          raw_set [token] [\"flags\"] [l] = {[\"present\"] = -1, [\"absent\"] = -1}\n        end\n      end\n    end\n  end\n\n  for i, creature in ipairs (df.global.world.raws.creatures.all) do\n    dfhack.println (creature.creature_id)\n    local matched = {}\n    \n    for k, str in ipairs (creature.raws) do\n      local token = strip (str [0])\n      \n      matched [token] = true\n      \n      for l, flag in ipairs (creature.flags) do\n        if raw_set [token] [\"flags\"] [l] [\"present\"] == -1 then\n          raw_set [token] [\"flags\"] [l] [\"present\"] = flag\n              \n        elseif raw_set [token] [\"flags\"] [l] [\"present\"] ~= flag then\n          raw_set [token] [\"flags\"] [l] [\"present\"] = 2  --  Redundant assignment when already mismatch\n        end\n      end\n    end\n    \n    for k, raw in pairs (raw_set) do\n      if not matched [k] then\n        for l, flag in ipairs (creature.flags) do\n          if raw_set [k] [\"flags\"] [l] [\"absent\"] == -1 then\n            raw_set [k] [\"flags\"] [l] [\"absent\"] = flag\n              \n          elseif raw_set [k] [\"flags\"] [l] [\"absent\"] ~= flag then\n            raw_set [k] [\"flags\"] [l] [\"absent\"] = 2  --  Redundant assignment when already mismatch\n          end\n        end\n      end\n    end\n  end\n  \n  for i, flag in ipairs (df.global.world.raws.creatures.all [0].flags) do\n    if flags [i] == -1 then  --  Skip flags that do not change.\n      dfhack.println (\"Flag:\", i, df.creature_raw_flags [i])\n      for k, raw in pairs (raw_set) do\n        if (raw [\"flags\"] [i] [\"present\"] == true or\n            raw [\"flags\"] [i] [\"present\"] == false) and\n           (raw [\"flags\"] [i] [\"absent\"] == true or\n            raw [\"flags\"] [i] [\"absent\"] == false) and\n           raw [\"flags\"] [i] [\"present\"] ~= raw [\"flags\"] [i] [\"absent\"] then\n          dfhack.println (\"\", k, raw [\"flags\"] [i] [\"present\"])\n        end\n      end\n    end\n  end\nend\n\nmatch_creature_raw_flags ()\n```","files":null}]}