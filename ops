{"version":1,"ops":[{"type":3,"author":{"id":"7c3935464acdaaae9d6fcb27abcbbe21ec75027f"},"timestamp":1526055760,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM4ODQxMzQ0Ng==","github-url":"https://github.com/DFHack/df-structures/issues/225#issuecomment-388413446"},"message":"I don't think that would work well in this case (or possibly in general, but that's another matter) because the type is at the *end*, so the \"base type\" would have to have 16 bytes of padding at the beginning or something like that.","files":null},{"type":5,"author":{"id":"7c3935464acdaaae9d6fcb27abcbbe21ec75027f"},"timestamp":1526055769,"metadata":{"github-id":"MDEyOkxhYmVsZWRFdmVudDE2MjIzMDE5NDA="},"added":["xml"],"removed":[]},{"type":3,"author":{"id":"dc07f1dff8eee6d97a060efd0e58b122b9009d24"},"timestamp":1526056815,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM4ODQxODIwMA==","github-url":"https://github.com/DFHack/df-structures/issues/225#issuecomment-388418200"},"message":"It's a bit of work to set up padding, but I don't see any problem apart from that, but I may fail to see the issues. There are high level languages that can do that with ease (I'm not sure if XML's \"choice\" can handle it, but I think it can. Obviously, that means nothing if the XML -\u003e C++ translation isn't present. After all, XML's \"sequence\" isn't used for vectors either).","files":null},{"type":3,"author":{"id":"7c3935464acdaaae9d6fcb27abcbbe21ec75027f"},"timestamp":1526060249,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM4ODQzMzQ4OA==","github-url":"https://github.com/DFHack/df-structures/issues/225#issuecomment-388433488"},"message":"Not sure what you're referring to by \"choice\" - we have our own XML schema that directly translates into C++ headers.\nSince this isn't a virtual class, we don't have any way to detect/convert it to subtypes automatically (like viewscreens and other virtual classes in Lua), so every user would have to cast it by hand, which is tedious and would require checking the \"type\" field by hand anyway.","files":null},{"type":3,"author":{"id":"dc07f1dff8eee6d97a060efd0e58b122b9009d24"},"timestamp":1526063371,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM4ODQ0Nzk1MA==","github-url":"https://github.com/DFHack/df-structures/issues/225#issuecomment-388447950"},"message":"Choice and Sequence are two XML Schema structure features. A Choice maps very well to Ada's Variant Record, which in C(++) terms would be a Union with the added functionality that one or more specified fields determine which variant (i.e. set of fields) is to be used. In Ada an exception is thrown if you try to access a field which doesn't exist for the variant at hand (as it also does if you try to access an array out of bounds).\nHowever, all of that is a tangent.\n\nIf it can't be converted into a virtual class with a reasonable effort I agree there's probably no good way to go about it, as the whole purpose of the exercise would be automatic subtype detection/conversion.","files":null},{"type":3,"author":{"id":"7c3935464acdaaae9d6fcb27abcbbe21ec75027f"},"timestamp":1526071123,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM4ODQ3OTMwNA==","github-url":"https://github.com/DFHack/df-structures/issues/225#issuecomment-388479304"},"message":"Ah, that makes sense, I think. I'm not sure that it would be applicable to us, though - we want something in XML that can be used to easily generate a union in C++, not a union in XML itself.\n\nDetermining which part of a union is valid is something we don't have support for yet. @ragundo was working on a big protobuf project that involved exporting some unions, and I'm not sure if he figured out a good way to handle them. In general, it's the field before the union that determines the union type, but this case is different, and in general, neither our XML nor code generation supports determining subtypes based on arbitrary fields (or even expressions).\n\nA bit of an aside, but it's possible that some small unions aren't really unions in DF - Toady could be using the same field for two completely different purposes, and someone decided to give them two different names in DFHack to better reflect that. I'm not sure if that's the case here or not, though.","files":null},{"type":4,"author":{"id":"7c3935464acdaaae9d6fcb27abcbbe21ec75027f"},"timestamp":1526071123,"metadata":{"github-id":"MDExOkNsb3NlZEV2ZW50MTYyMjc0NDM4Nw=="},"status":2},{"type":3,"author":{"id":"c49d776d8bb9c3344c0c6571e15cc127015e3e6c"},"timestamp":1526175990,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM4ODU5NTE0OQ==","github-url":"https://github.com/DFHack/df-structures/issues/225#issuecomment-388595149"},"message":"Yes\nI faced that problem and there's no solution.\nBecasue I was generating protocol buffers files, I just set each field of the union with a protobuf \"optional\" field and generate a method that can retrieve that field on the client side.\nIt's up to the client to decide which method to call on the dfhack side because there's no way to know the field that selects the correct union field","files":null}]}