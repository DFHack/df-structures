{"version":1,"ops":[{"type":3,"author":{"id":"7c3935464acdaaae9d6fcb27abcbbe21ec75027f"},"timestamp":1526482260,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM4OTU0NzI5OQ==","github-url":"https://github.com/DFHack/df-structures/issues/259#issuecomment-389547299"},"message":"From static.fields-i.inc:\n```c++\n  static const struct_field_info incident_doT_Dot_T_unk_v42_1_fields[] = {\n    { FLD(POINTER, t6), identity_traits\u003cdf::incident_sub6 \u003e::get(), 2, NULL },\n    { FLD(POINTER, t7), identity_traits\u003cdf::incident_sub7 \u003e::get(), 2, NULL },\n    { FLD(POINTER, t8), identity_traits\u003cdf::incident_sub8 \u003e::get(), 2, NULL },\n    { FLD(POINTER, t9), identity_traits\u003cdf::incident_sub9 \u003e::get(), 2, NULL },\n    { FLD(POINTER, t10), identity_traits\u003cdf::incident_sub10 \u003e::get(), 2, NULL },\n    { FLD_END }\n  };\n```\nThe \"2\" is a flag which I believe indicates that these fields should get skipped in pairs(). This is intended to avoid crashes in things like the union in ui_look_list, which has a union including a few pointers to classes with vtables, and even iterating over those will crash. I'll try to figure out why that flag is getting set here, though, since it should be safe enough.","files":null},{"type":3,"author":{"id":"7c3935464acdaaae9d6fcb27abcbbe21ec75027f"},"timestamp":1526482609,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM4OTU0OTUwMg==","github-url":"https://github.com/DFHack/df-structures/issues/259#issuecomment-389549502"},"message":"Found in StructFields.pm:\n```perl\n        $count |= 2 if $in_union || is_attr_true($field, 'has-bad-pointers');\n```\nThis was originally just\n```perl\n     $count |= 2 if $in_union\n```\nbut was expanded to allow the `has-bad-pointers` attribute to skip uninitialized pointers to virtual class instances outside of unions too.\nAlso, the check for this flag in LuaTypes.cpp was changed as follows:\n```diff\n-            // Skip class-typed pointers within unions\n-            if ((fields[i].count \u0026 2) != 0 \u0026\u0026 fields[i].type \u0026\u0026\n-                fields[i].type-\u003etype() == IDTYPE_CLASS)\n+            // Skip class-typed pointers within unions and other bad pointers\n+            if ((fields[i].count \u0026 2) != 0 \u0026\u0026 fields[i].type)\n```\nto support 4c224dd20567a9eda652ca9522bd0547be4bf358.\nMaybe we need to use two flags here - one for \"virtual class in union\" and one for \"bad pointer\".","files":null},{"type":3,"author":{"id":"dc07f1dff8eee6d97a060efd0e58b122b9009d24"},"timestamp":1526498784,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM4OTYzNzE2MQ==","github-url":"https://github.com/DFHack/df-structures/issues/259#issuecomment-389637161"},"message":"Well, casting a pointer to the wrong type is dangerous, and that's essentially what a union of pointers is. The types pointed to contain vectors, and I'd assume interpreting binary patterns which aren't vectors as if they were to be potentially harmful. However, hiding them from view isn't the right thing either. Toady surely is using some kind of logic other than \"just make sure to always select the correct one\" to organize these unions in a somewhat safe manner, but I guess we just don't know what.\n\nIf I understand the current case correctly, it should be possible to change the \"in union\" automatic flag assignment to explicit \"has-bad-pointers\" assignments on the unions that do have elements with \"bad\" pointers in the form of vtables? It probably won't hurt to have two separate flags that for the time being have the same effect, though, as it would allow for future separation of the handling of the two cases.","files":null},{"type":3,"author":{"id":"7c3935464acdaaae9d6fcb27abcbbe21ec75027f"},"timestamp":1526499250,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDM4OTYzOTQyNQ==","github-url":"https://github.com/DFHack/df-structures/issues/259#issuecomment-389639425"},"message":"In the case of classes with vtable pointers, we have two choices: hide them or crash. In this case, they're structs, so I think we can make them visible. Printing an invalid vector (e.g. in a union) is fine; printing its contents is not.\n\nThe point I was making is that ALL classes with vtable pointers in unions need to be hidden in Lua. Formerly, this was done by setting the \"in union\" flag (2) on all fields in unions in perl, then checking whether a field was a virtual class (that's IDTYPE_CLASS above) in LuaTypes.cpp before actually skipping it. Requiring every class field in a union to have an explicit \"in-union\" or \"has-bad-pointers\" attribute in XML isn't good because it's something we can already determine automatically, it *needs* to be done for every class field in a union, and if someone forgets to add it (to an existing or new field), it will lead to crashes.","files":null}]}